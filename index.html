<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TiffyAI â€” Playground (blocks + magic)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <!-- particle system -->
  <script src="https://cdn.jsdelivr.net/gh/IdeaSpaceVR/aframe-particle-system-component@1.0.0/dist/aframe-particle-system-component.min.js"></script>

  <style>
    html,body { height:100%; margin:0; background:#000; font-family:monospace; }
    #scoreBox {
      position: absolute;
      top: 8px;
      left: 12px;
      background: rgba(0,0,0,0.35);
      color: #00f0ff;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid rgba(0,255,255,0.12);
      z-index: 9999;
      font-size: 14px;
      backdrop-filter: blur(6px);
    }
    /* tiny helper to make the VR button visible on mobile when embedded */
    a-scene { width:100vw; height:100vh; }
  </style>
</head>
<body>

<div id="scoreBox">TIFFY Earnings: 0.000000</div>

<a-scene background="color: #000" embedded vr-mode-ui="enabled: true">

  <a-assets>
    <!-- environment (raw GitHub links) -->
    <video id="frontVideo" autoplay loop muted playsinline crossorigin="anonymous"
      src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/back.mp4"></video>
    <video id="backVideo" autoplay loop muted playsinline crossorigin="anonymous"
      src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/front.mp4"></video>
    <video id="leftVideo" autoplay loop muted playsinline crossorigin="anonymous"
      src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/left.mp4"></video>
    <video id="topVideo" autoplay loop muted playsinline crossorigin="anonymous"
      src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/top.mp4"></video>
    <video id="bottomVideo" autoplay loop muted playsinline crossorigin="anonymous"
      src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/bottom.mp4"></video>

    <!-- enemy mp4 (used as a video texture on all cube faces) -->
    <video id="enemyVideo" autoplay loop muted playsinline crossorigin="anonymous"
      src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/enemies.mp4"></video>

    <!-- sounds -->
    <audio id="shootSound" src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/fire.wav"></audio>
    <audio id="explodeSound" src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/blocks.wav"></audio>
    <audio id="swoochSound" src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/swooch.wav"></audio>
    <audio id="bgMusic" src="https://raw.githubusercontent.com/TiffyAI/Tiffyverse/refs/heads/main/assets/playing.wav" crossorigin="anonymous"></audio>
  </a-assets>

  <!-- Environment: extended wide/deep area -->
  <!-- front is close so camera lines up with front.mp4 -->
  <a-plane src="#frontVideo" position="0 1.8 -6" rotation="0 0 0" width="18" height="10"></a-plane>

  <!-- deep back plane that gives distance (very wide & tall) -->
  <a-plane src="#backVideo" position="0 15 140" rotation="0 180 0" width="320" height="160"></a-plane>

  <!-- Left long wall -->
  <a-plane src="#leftVideo" position="-160 25 60" rotation="0 90 0" width="320" height="160"></a-plane>

  <!-- Pyramid-like right side made of two angled planes for depth (we use leftVideo for texture) -->
  <a-plane src="#leftVideo" position="160 35 10" rotation="0 -30 0" width="320" height="160"></a-plane>
  <a-plane src="#leftVideo" position="160 35 110" rotation="0 -150 0" width="320" height="160"></a-plane>

  <!-- Top & bottom long -->
  <a-plane src="#topVideo" position="0 400 60" rotation="90 0 0" width="800" height="640"></a-plane>
  <a-plane src="#bottomVideo" position="0 -120 60" rotation="-90 0 0" width="800" height="640"></a-plane>

  <!-- Camera: tightened against front.mp4, closer forward so hand area lines up -->
  <a-entity id="player" camera look-controls position="0 1.6 -2.5"></a-entity>

</a-scene>

<script>
/* ---------- Setup & autoplay ---------- */
const scene = document.querySelector('a-scene');
const camera = document.getElementById('player');
const scoreBox = document.getElementById('scoreBox');

window.addEventListener('load', () => {
  // ensure videos attempt to play on mobile (muted)
  ['frontVideo','backVideo','leftVideo','topVideo','bottomVideo','enemyVideo'].forEach(id=>{
    const v = document.getElementById(id);
    if (v) { v.muted = true; v.play().catch(()=>{}); }
  });
  // background music - some browsers require user gesture to start audio
  const bg = document.getElementById('bgMusic');
  if (bg) { bg.volume = 0.25; bg.loop = true; bg.play().catch(()=>{}); }
});

/* ---------- Game state ---------- */
let enemies = [];   // array of {el, speed, rotSpeed}
let projectiles = []; // array of {el, dir, speed, hueTick}
let spawnTimer = 0;
const spawnInterval = 900; // ms (more frequent, spread controlled)
let lastTime = performance.now();

// Score handling (0.002 TIFFY per enemy)
function getScore(){ return parseFloat(localStorage.getItem('tetrusScore') || '0'); }
function addScore(value){
  let s = getScore() + value;
  s = Math.round(s * 1e6) / 1e6;
  localStorage.setItem('tetrusScore', s.toString());
  scoreBox.textContent = `TIFFY Earnings: ${s.toFixed(6)}`;
}
scoreBox.textContent = `TIFFY Earnings: ${getScore().toFixed(6)}`;

/* ---------- Sounds helper ---------- */
function playSound(id, vol=1.0){
  const src = document.getElementById(id);
  if(!src) return;
  try{
    const node = src.cloneNode();
    node.volume = vol;
    node.play().catch(()=>{});
  }catch(e){}
}

/* ---------- Helper to spawn enemies in a wide area without stacking ---------- */
function spawnEnemy() {
  // create a cube that will have the enemy video mapped onto its faces
  const cube = document.createElement('a-box');

  // apply video texture to all faces by applying material src
  // Note: using mp4 as texture is fine on the cube; it will tile across faces.
  cube.setAttribute('material', 'src: #enemyVideo; repeat: 1 1; shader: standard; roughness: 0.8; metalness: 0.15');

  // size
  cube.setAttribute('width', 4);
  cube.setAttribute('height', 4);
  cube.setAttribute('depth', 4);

  // pick a random side and position it far out along that side with spread so they don't overlap
  // spawn radius area parameters
  const minDist = 70;
  const maxDist = 160;
  const side = Math.floor(Math.random() * 4); // 0=back,1=left,2=right,3=front (we allow all around now)
  const pos = new THREE.Vector3();

  // helper to find a free position (avoid bunching)
  function randomPosForSide(s) {
    for (let tries=0; tries<10; tries++){
      let x=0,z=0;
      if(s===0){ // back (positive z direction)
        x = (Math.random()*240) - 120;
        z = minDist + Math.random() * (maxDist - minDist);
      } else if(s===1){ // left (negative x)
        x = - (minDist + Math.random() * (maxDist - minDist));
        z = (Math.random()*240) - 120;
      } else if(s===2){ // right (positive x)
        x = (minDist + Math.random() * (maxDist - minDist));
        z = (Math.random()*240) - 120;
      } else { // front (negative z)
        x = (Math.random()*240) - 120;
        z = - (minDist + Math.random() * (maxDist - minDist));
      }
      const y = 2 + Math.random()*6;
      // ensure not too close to existing enemies
      let coll=false;
      for(const e of enemies){
        const p = e.el.object3D.position;
        if(p.distanceTo(new THREE.Vector3(x,y,z)) < 8){ coll=true; break; }
      }
      if(!coll) return new THREE.Vector3(x,y,z);
    }
    // fallback random
    return new THREE.Vector3((Math.random()*240)-120, 2+Math.random()*6, (Math.random()*240)-120);
  }

  const posVec = randomPosForSide(side);
  cube.object3D.position.copy(posVec);

  // random rotation
  cube.object3D.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

  // add to scene
  scene.appendChild(cube);

  // set speed (how fast it moves toward a target point near front)
  const speed = 0.04 + Math.random()*0.12;
  const rotSpeed = (Math.random()*2 - 1) * 0.02;

  enemies.push({ el: cube, speed, rotSpeed });

  // swooch sound
  playSound('swoochSound', 0.45);
}
// === Projectiles ===
function createProjectile() {
  const geometry = new THREE.SphereGeometry(0.2, 16, 16);
  const material = new THREE.MeshStandardMaterial({
    emissive: new THREE.Color(0xffffff),
    emissiveIntensity: 2,
    transparent: true,
    opacity: 0.9
  });
  const projectile = new THREE.Mesh(geometry, material);

  // rainbow color shift
  projectile.userData.hue = Math.random();

  projectile.position.copy(camera.position);
  scene.add(projectile);
  projectiles.push(projectile);

  // trail
  const trail = new THREE.TrailRenderer(scene, false);
  const trailMaterial = TrailRenderer.createBaseMaterial();
  trailMaterial.uniforms.headColor.value.set(0xffffff);
  trailMaterial.uniforms.tailColor.value.set(0x0000ff);
  trail.setMaterial(trailMaterial, true);
  trail.initialize(camera, projectile);
  projectile.userData.trail = trail;

  return projectile;
}

function updateProjectiles(delta) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.position.add(p.getWorldDirection(new THREE.Vector3()).multiplyScalar(1 * delta));

    // rainbow effect
    p.userData.hue += 0.01;
    const color = new THREE.Color().setHSL(p.userData.hue % 1, 1, 0.5);
    p.material.emissive.set(color);

    if (p.userData.trail) {
      p.userData.trail.advance();
    }
  }
}

// === Enemy explosion ===
function explodeEnemy(enemy) {
  const pieces = [];
  const enemyPos = enemy.position.clone();

  for (let i = 0; i < 6; i++) {
    const geom = new THREE.BoxGeometry(0.3, 0.3, 0.3);
    const mat = new THREE.MeshStandardMaterial({
      color: enemy.material.color,
      emissive: new THREE.Color(0xff0000),
      emissiveIntensity: 1
    });
    const piece = new THREE.Mesh(geom, mat);

    piece.position.copy(enemyPos);
    piece.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 2,
      (Math.random() - 0.5) * 2,
      (Math.random() - 0.5) * 2
    );

    scene.add(piece);
    pieces.push(piece);
  }

  // animate & fade
  let life = 1.0;
  const animateExplosion = () => {
    life -= 0.02;
    pieces.forEach(piece => {
      piece.position.add(piece.velocity.clone().multiplyScalar(0.1));
      piece.material.opacity = life;
      piece.material.transparent = true;
    });
    if (life > 0) {
      requestAnimationFrame(animateExplosion);
    } else {
      pieces.forEach(piece => scene.remove(piece));
    }
  };
  animateExplosion();

  scene.remove(enemy);
}
/* ---------- Shooting: glowing spheres with trailing particle system ---------- */
function shootProjectile(){
  const sphere = document.createElement('a-sphere');
  sphere.setAttribute('radius', 0.4);
  sphere.setAttribute('segments-width', 16);
  sphere.setAttribute('segments-height', 12);
  // initial material; color/emissive will be updated in tick
  sphere.setAttribute('material', 'shader: standard; emissive: #00ffff; emissiveIntensity: 1; metalness:0.05; roughness:0.2');

  // place slightly in front of camera (use world coordinate)
  const start = camera.object3D.getWorldPosition(new THREE.Vector3());
  const forward = new THREE.Vector3();
  camera.object3D.getWorldDirection(forward);
  const spawnPos = start.clone().add(forward.clone().multiplyScalar(1.3));
  sphere.object3D.position.copy(spawnPos);

  // attach mystical particle trail (parented so it moves with sphere)
  const trail = document.createElement('a-entity');
  trail.setAttribute('particle-system', {
    preset: 'dust',
    particleCount: 80,
    color: '#00ffff,#88ffcc,#ffffff',
    size: 0.06,
    velocityValue: '0 0 0',
    spread: '0.22 0.22 0.22',
    duration: 0.6
  });
  sphere.appendChild(trail);

  scene.appendChild(sphere);

  // velocity vector (move forward along camera direction)
  const dir = forward.clone().normalize();
  // make speed fairly quick on big map
  const speed = 1.2 + Math.random()*0.6;

  projectiles.push({ el: sphere, dir, speed, hueTick: Math.random()*360 });

  // shoot sound
  playSound('shootSound', 0.9);
}

/* ---------- Explosion: particle burst + tiny fragments ---------- */
function explodeAt(position){
  // particle burst
  const burst = document.createElement('a-entity');
  burst.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
  burst.setAttribute('particle-system', {
    preset: 'snow',
    particleCount: 200,
    color: '#ffdd99,#ffffff,#ff9933',
    size: 0.07,
    velocityValue: '0.8 1.2 0.8',
    spread: '1 1 1',
    duration: 0.85
  });
  scene.appendChild(burst);
  setTimeout(()=>{ if(burst.parentNode) burst.parentNode.removeChild(burst); }, 1000);

  // small cube fragments
  for(let i=0;i<12;i++){
    const piece = document.createElement('a-box');
    piece.setAttribute('width','0.25'); piece.setAttribute('height','0.25'); piece.setAttribute('depth','0.25');
    piece.setAttribute('material','color:#9a7f6c; metalness:0.1; roughness:0.8');
    piece.object3D.position.copy(position);
    scene.appendChild(piece);

    // random direction and animate out
    const randDir = new THREE.Vector3((Math.random()*2-1),(Math.random()*1.4),(Math.random()*2-1)).normalize();
    const travel = 1.2 + Math.random()*1.8;
    const duration = 600 + Math.random()*500;
    const start = performance.now();
    const animatePiece = (t)=>{
      const dt = (t - start) / duration;
      if(dt >= 1){
        if(piece.parentNode) piece.parentNode.removeChild(piece);
        return;
      }
      piece.object3D.position.copy(position).add(randDir.clone().multiplyScalar(travel * dt));
      piece.object3D.rotation.x += 0.3;
      piece.object3D.rotation.y += 0.25;
      requestAnimationFrame(animatePiece);
    };
    requestAnimationFrame(animatePiece);
  }

  // explosion sound
  playSound('explodeSound', 0.9);
}

/* ---------- Collision test ---------- */
function isColliding(aEl, bEl, threshold = 1.6){
  if(!aEl || !bEl) return false;
  return aEl.object3D.position.distanceTo(bEl.object3D.position) < threshold;
}

/* ---------- Main loop ---------- */
function tick(now){
  const dt = now - lastTime;
  lastTime = now;

  // spawn new enemies regularly but keep spread
  spawnTimer += dt;
  if(spawnTimer > spawnInterval){
    spawnTimer = 0;
    // spawn 1..3 enemies, but spread them so they don't clump
    const toSpawn = 1 + (Math.random() < 0.15 ? 1 : 0);
    for(let i=0;i<toSpawn;i++) spawnEnemy();
  }

  // update enemies
  for(let i = enemies.length-1; i >= 0; i--){
    const e = enemies[i];
    // slight random wobble rotation each tick
    e.el.object3D.rotation.x += (Math.random()-0.5) * e.rotSpeed;
    e.el.object3D.rotation.y += (Math.random()-0.5) * e.rotSpeed;

    // move toward a point slightly in front of the camera (so they approach the play area)
    const target = camera.object3D.position.clone().add(new THREE.Vector3(0,0,-1.5));
    const dir = new THREE.Vector3().subVectors(target, e.el.object3D.position).normalize();
    // small lateral jitter
    dir.x += (Math.random()-0.5)*0.02;
    dir.z += (Math.random()-0.5)*0.02;
    e.el.object3D.position.add(dir.multiplyScalar(e.speed));

    // if they reach too close to player, explode them (no score)
    if(e.el.object3D.position.distanceTo(camera.object3D.position) < 1.2){
      explodeAt(e.el.object3D.position.clone());
      if(e.el.parentNode) e.el.parentNode.removeChild(e.el);
      enemies.splice(i,1);
    }
  }

  // update projectiles: move forward, change color, add faint trail impulse, check collisions
  for(let p = projectiles.length-1; p >= 0; p--){
    const proj = projectiles[p];
    // move
    proj.el.object3D.position.add(proj.dir.clone().multiplyScalar(proj.speed));

    // color cycling (emissive)
    proj.hueTick += 6 + Math.random()*8;
    const h = Math.floor(proj.hueTick % 360);
    proj.el.setAttribute('material', `shader: standard; emissive: hsl(${h} 100% 60%); emissiveIntensity: 1.2; metalness:0.05; roughness:0.2`);

    // small extra particle pops to emphasize trail (not necessary but nice)
    // (we rely on parented particle-system for continuous trail)

    // remove if far away
    if(proj.el.object3D.position.distanceTo(camera.object3D.position) > 240){
      if(proj.el.parentNode) proj.el.parentNode.removeChild(proj.el);
      projectiles.splice(p,1);
      continue;
    }

    // check collision with enemies
    for(let eI = enemies.length-1; eI >= 0; eI--){
      const e = enemies[eI];
      if(isColliding(proj.el, e.el, 2.6)){ // cubes larger so use bigger threshold
        const pos = e.el.object3D.position.clone();
        // explosion effect
        explodeAt(pos);
        // remove enemy & projectile
        if(e.el.parentNode) e.el.parentNode.removeChild(e.el);
        if(proj.el.parentNode) proj.el.parentNode.removeChild(proj.el);
        enemies.splice(eI,1);
        projectiles.splice(p,1);

        // award score 0.002 TIFFY
        addScore(0.002);

        break;
      }
    }
  }

  requestAnimationFrame(tick);
}

/* ---------- Input (shoot on tap/click) ---------- */
window.addEventListener('click', (e)=>{
  // avoid firing when clicking UI or controls: allow always for simplicity
  shootProjectile();
});

/* ---------- start loop ---------- */
lastTime = performance.now();
requestAnimationFrame(tick);

</script>
</body>
</html>
